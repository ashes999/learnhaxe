<?xml version="1.0" encoding="utf-8"?>
      <feed xmlns="http://www.w3.org/2005/Atom">
        <title>Learn Haxe</title>
        <link href="http://ashes999.github.io/learnhaxe" />
        <id>urn:uuid:51e6386ca9155b4889db67f17ba6089f</id>
  	    <updated>2016-09-30T00:00:00Z</updated><entry>
      		<title>Loading Json in kha</title>
          <link href="http://ashes999.github.io/learnhaxe/loading-json-in-kha" />
      		<id>urn:uuid:4b287d4050b5cd64855b26a1f574edf9</id>
      		<updated>2016-09-30T00:00:00Z</updated>
      		<summary>Loading Json in kha</summary>
      		<content type="xhtml">
      			&lt;p&gt;With some macro magic, Kha allows you to load assets asynchronously. Here's how that looks with images:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Assets.loadEverything(function()
{
  var playerImage = Assets.images.player;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have a &lt;code&gt;player.png&lt;/code&gt; file in &lt;code&gt;Assets/images&lt;/code&gt;, this snippet loads that data into the &lt;code&gt;playerImage&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;That works great with images, but what about JSON? Can I add &lt;code&gt;monsters.json&lt;/code&gt; to &lt;code&gt;Assets/data&lt;/code&gt; and load it with &lt;code&gt;Assets.images.data.monsters&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Nope. This doesn't compile; if you check the &lt;a href="http://api.kha.technology/kha/Assets.html"&gt;Assets class documentation&lt;/a&gt;, you'll notice that it has &lt;code&gt;blobs&lt;/code&gt;, &lt;code&gt;fonts&lt;/code&gt;, &lt;code&gt;images&lt;/code&gt;, &lt;code&gt;sounds&lt;/code&gt;, &lt;code&gt;videos&lt;/code&gt;. Of these, &lt;code&gt;blobs&lt;/code&gt; looks promising, but the documentation for &lt;code&gt;BlobList&lt;/code&gt; is non-existent.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KTXSoftware/Kha/wiki/Managing-Your-Assets"&gt;Some of the wiki documentation&lt;/a&gt; mentions that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any other format [other than images, sounds, and vidos] will not be changed and will be available in your code through &lt;code&gt;Assets.blobs&lt;/code&gt; as &lt;code&gt;Bytes&lt;/code&gt;.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;It turns out that you can load your data using &lt;code&gt;Assets.blobs.monsters_json&lt;/code&gt;. This is a little unintuitive (no directory structure/naming?), but it works. It also gives you back &lt;code&gt;Bytes&lt;/code&gt;; you can call &lt;code&gt;.toString()&lt;/code&gt; on it to read it as text.&lt;/p&gt;
&lt;p&gt;If we put this JSON into &lt;code&gt;Assets/data/monsters.json&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    "names": [
        "slime", "bat", "spider"
    ]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use this code to get back &lt;code&gt;names&lt;/code&gt; as an &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Assets.loadEverything(function()
{
    var monsterNames = Json.parse(Assets.blobs.monsters_json.toString()).names;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try to keep your filenames distinct, even across directories, to avoid naming collisions.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Collision Detection and Resolution in Luxe</title>
          <link href="http://ashes999.github.io/learnhaxe/collision-detection-and-resolution-in-luxe" />
      		<id>urn:uuid:e22e476cab81cb5813effdef1f758eff</id>
      		<updated>2016-07-29T00:00:00Z</updated>
      		<summary>Collision Detection and Resolution in Luxe</summary>
      		<content type="xhtml">
      			&lt;p&gt;Disclaimer: I just started using Luxe. First impression: engine seems very usable (great API design) and things work well. But, very poorly documented (API docs are sparse and there aren't many blog posts about how to do things using Luxe.)&lt;/p&gt;
&lt;p&gt;I'm working on a &lt;a href="https://github.com/ashes999/opal-quest/tree/luxe"&gt;small arena 2D shooter in Luxe&lt;/a&gt;. I have a ship (&lt;code&gt;Sprite&lt;/code&gt; instance) and a bunch of walls (also &lt;code&gt;Sprite&lt;/code&gt; instances). How can I:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Find out when the ship hits a wall?&lt;/li&gt;&lt;li&gt;Prevent the ship from moving into the wall, or move the ship back out of the wall after the collision?&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Luxe includes a number of packages/classes related to collision detection. I stumbled upon the &lt;a href="http://luxeengine.com/docs/api/luxe/collision/shapes/Polygon.html"&gt;&lt;code&gt;Polygon&lt;/code&gt; class&lt;/a&gt;. It includes two helpful methods:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Polygon.rectangle(x, y, width, height):&lt;/code&gt; create a rectangular polygon, specifying position and size.&lt;/li&gt;&lt;li&gt;&lt;code&gt;polygonInstance.testPolygon(polygon):&lt;/code&gt; check if &lt;code&gt;polygonInstance&lt;/code&gt; intersects &lt;code&gt;testPolygon&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;if &lt;code&gt;testPolygon&lt;/code&gt; finds an intersection, it returns a non-null object with a number of fields. Of interest to us is the &lt;code&gt;separation&lt;/code&gt; property, which tells us how much to move &lt;code&gt;polygonInstance&lt;/code&gt; to get it to stop colliding with &lt;code&gt;polygon&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Putting these together, we get something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var shipPolygon = Polygon.rectangle(ship.pos.x, ship.pos.y, ship.size.x, ship.size.y);
var wallPolygon = Polygon.rectangle(wall.pos.x, wall.pos.y, wall.size.x, wall.size.y);
var result = shipPolygon.testPolygon(wall);
if (result != null)
{
    ship.pos.x += result.separation.x;
    ship.pos.y += result.separation.y;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This correctly causes the &lt;code&gt;ship&lt;/code&gt; to stop when it hits &lt;code&gt;wall&lt;/code&gt;.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Testing Private Code with @:allow and @:access</title>
          <link href="http://ashes999.github.io/learnhaxe/testing-private-code-with-allow-and-access" />
      		<id>urn:uuid:b7bbe82da7312f82e7af4f867378b96c</id>
      		<updated>2016-03-28T00:00:00Z</updated>
      		<summary>Testing Private Code with @:allow and @:access</summary>
      		<content type="xhtml">
      			&lt;p&gt;When writing unit tests, you sometimes face the choice of changing class/method/property access to &lt;code&gt;public&lt;/code&gt; instead of &lt;code&gt;private&lt;/code&gt; to facilitate testing. Sometimes, it can feel like a terrible decision to break the public interface of a class &lt;em&gt;just&lt;/em&gt; to make it easier to test.&lt;/p&gt;
&lt;p&gt;Fortunately, you don't have to do that. Haxe allows you to annotate classes and methods with two access modifiers:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;@:allow(package.and.class.Name)&lt;/code&gt;: Allow the class &lt;code&gt;Name&lt;/code&gt; in the namespace &lt;code&gt;package.and.class&lt;/code&gt; to access this class' private methods and properties.&lt;/li&gt;&lt;li&gt;&lt;code&gt;@:access(package.and.class.Name)&lt;/code&gt;: allow this method/class to access &lt;code&gt;package.and.class.Name&lt;/code&gt;'s private methods and properties. Useful when you can't modify the class you want to test, or it's impractical to give access to all the test classes that need it.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;(You can read more about them on the &lt;a href="http://haxe.org/manual/lf-access-control.html"&gt;Access Control documentation page&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;A word of caution: this borders on white-box testing (i.e. verifying the implementation works in a specific way) -- which creates fragile tests that require frequent change. I suggest, as much as possible, &lt;em&gt;not to rely on private code for testing&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Instead, rely on some observable, public properties or methods that allow you to &lt;em&gt;indirectly&lt;/em&gt;. For example, if you have a &lt;code&gt;Player&lt;/code&gt; class in an RPG, you probably can't test the &lt;code&gt;levelUp&lt;/code&gt; method directly; instead, you can grant your player lots of experience, and observe that it eventually does level up.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Integration Testing in MUnit with HaxeFlixel</title>
          <link href="http://ashes999.github.io/learnhaxe/integration-testing-in-munit-with-haxeflixel" />
      		<id>urn:uuid:0a38c32179c21134e55c625511b016b9</id>
      		<updated>2016-03-28T00:00:00Z</updated>
      		<summary>Integration Testing in MUnit with HaxeFlixel</summary>
      		<content type="xhtml">
      			&lt;p&gt;How can you test your HaxeFlixel game code? Testing games is tricky, because it's often hard to circumvent/simulate input (keyboard, mouse, etc.), and view code is often tightly coupled to logic.&lt;/p&gt;
&lt;p&gt;HaxeFlixel's demos (probably inadvertantly) encourage a simple, direct style of development where you throw most of your code into states. This makes it difficult to test.&lt;/p&gt;
&lt;h3&gt;Testing Strategies&lt;/h3&gt;
&lt;p&gt;I suggest you use two strategies for testing:&lt;/p&gt;
&lt;p&gt;1) As much as possible, &lt;strong&gt;write your logic in simple Haxe classes.&lt;/strong&gt; Keep as much logic as you can out of &lt;code&gt;FlxState&lt;/code&gt; classes, and try not to extend the Flixel classes.  This makes it difficult to handle things like "create a &lt;code&gt;Player&lt;/code&gt; class that responds to keyboard input." To do this, you probably need an abstraction (method/event) in the &lt;code&gt;Player&lt;/code&gt; class that responds to input, and some code in an &lt;code&gt;InputSystem&lt;/code&gt; class or the &lt;code&gt;FlxState&lt;/code&gt; that broadcasts input when it receives it from HaxeFlixel. Which brings me to the second strategy.&lt;/p&gt;
&lt;p&gt;2) &lt;strong&gt;Test whatever is easy to test in your &lt;code&gt;FlxState&lt;/code&gt; classes.&lt;/strong&gt; You almost certainly cannot test everything (and have to go through great lengths to test everything). Sometimes, the cost and complexity doesn't justify the fragile tests. Test whatever you can reasonably test.&lt;/p&gt;
&lt;h3&gt;Testing with HaxeFlixel&lt;/h3&gt;
&lt;p&gt;Since unit testing simple Haxe classes with &lt;code&gt;munit&lt;/code&gt; is easy, I documented the steps you need to set up integration testing.  The key is to realize that &lt;strong&gt;instead of using MUnit, you'll use lime as the test runner.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Why? Because, as Gama11 mentioned &lt;a href="https://groups.google.com/d/msg/haxeflixel/ow87nKG3t80/eKI4KFDtAAAJ"&gt;here&lt;/a&gt;, HaxeFlixel relies on &lt;code&gt;lime&lt;/code&gt; to build projects. Lime performs additional processing, like including libraries from &lt;code&gt;include.xml&lt;/code&gt; files.&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;Delete your &lt;code&gt;test.hxml&lt;/code&gt; file.&lt;/strong&gt; You won't need it. &lt;/p&gt;
&lt;p&gt;2)  &lt;strong&gt;Add a &lt;code&gt;project.xml&lt;/code&gt; file to your &lt;code&gt;test&lt;/code&gt; folder.&lt;/strong&gt; You can use this as a starter.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;project&amp;gt;
	&amp;lt;meta title="UnitTests" version="1.0.0" /&amp;gt;
	&amp;lt;app file="TestMain" main="TestMain" /&amp;gt;
	
	&amp;lt;set name="SWF_VERSION" value="11.8" /&amp;gt;
	&amp;lt;source path="../src" /&amp;gt;
	
	&amp;lt;set name="no-custom-backend" /&amp;gt;
	&amp;lt;set name="unit-test" /&amp;gt;
	
	&amp;lt;haxelib name="munit" /&amp;gt;
	&amp;lt;haxelib name="flixel" /&amp;gt;
	&amp;lt;haxelib name="hamcrest" /&amp;gt;
	
	&amp;lt;haxedef name="FLX_UNIT_TEST" /&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This transforms your &lt;code&gt;test&lt;/code&gt; directory into a stand-alone HaxeFlixel project that you can build with &lt;code&gt;lime&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;3) &lt;strong&gt;Modify &lt;code&gt;TestMain.hx&lt;/code&gt;.&lt;/strong&gt; (If you don't have a copy, run &lt;code&gt;haxelib run munit test&lt;/code&gt; to generate one.) Add two lines as the first two lines in the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public function new()
{
   // Flixel was not designed for unit testing so we can only have one instance for now.
   Lib.current.stage.addChild(new FlxGame(800, 600, null, 1, 60, 60, true));
   // ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(The comment comes from the same line in the HaxeFlixel code base.)&lt;/p&gt;
&lt;p&gt;That's it! Now you can write code instantiating and using &lt;code&gt;FlxState&lt;/code&gt; instances like normal, and testing conditions.&lt;/p&gt;
&lt;p&gt;To run the tests, just run &lt;code&gt;lime test &amp;lt;platform&amp;gt;&lt;/code&gt; from the &lt;code&gt;test&lt;/code&gt; directory. (Neko works out of the box; Flash requires some additional trickery to send the results to the MUnit test runner.)&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Deserializing Class Instances From Json</title>
          <link href="http://ashes999.github.io/learnhaxe/deserializing-class-instances-from-json" />
      		<id>urn:uuid:bb1689ef576deb85044a94ac76e98bf6</id>
      		<updated>2016-03-22T00:00:00Z</updated>
      		<summary>Deserializing Class Instances From Json</summary>
      		<content type="xhtml">
      			&lt;p&gt;If you google for how to deserialize some JSON into a Haxe class, you will most likely find &lt;a href="http://haxe.org/manual/std-Json-parsing.html"&gt;this API page on JSON parsing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While this method allows you to deserialize JSON into a struct, it only works with a &lt;code&gt;typedef&lt;/code&gt;. It won't work with an actual class (something that has methods).&lt;/p&gt;
&lt;p&gt;The good news is that it is possible to deserialize to a class instance; the bad news is that it relies on reflection. The snippet below uses reflection to iterate over all fields in the &lt;code&gt;dynamic&lt;/code&gt; instance returned by &lt;code&gt;haxe.json.parse&lt;/code&gt;, and reflectively sets the values on &lt;code&gt;myInstance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var raw = haxe.Json.parse(sys.io.File.getContent(configFile));
var myInstance:WhateverClassYouWant = new WhateverClassYouWant();

var structsFields:Array&amp;lt;String&amp;gt; = Reflect.fields(raw);
var classFields:Array&amp;lt;String&amp;gt; = Type.getInstanceFields(Type.getClass(myInstance));

for (field in structsFields)
{
    if (classFields.indexOf(field) &amp;gt; -1)
    {
        var value:Dynamic = Reflect.field(raw, field);
        Reflect.setField(myInstance, field, value);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A couple of caveats to pay attention to:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;We only set the field on &lt;code&gt;myInstance&lt;/code&gt; if it exists. This is safer than trusting the JSON blindly.&lt;/li&gt;&lt;li&gt;Any fields that aren't in &lt;code&gt;raw&lt;/code&gt; (or in the JSON) won't be set, and will have their default values.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;As it stands, this solution can work pretty well as a class deserializer. You can use a similar method to reflect and serialize a class to JSON.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Haxeflixel in Cloud9</title>
          <link href="http://ashes999.github.io/learnhaxe/haxeflixel-in-cloud9" />
      		<id>urn:uuid:3741e7b78126e1586fbca302ff187643</id>
      		<updated>2016-03-12T00:00:00Z</updated>
      		<summary>Haxeflixel in Cloud9</summary>
      		<content type="xhtml">
      			&lt;p&gt;&lt;a href="https://c9.io/"&gt;Cloud9&lt;/a&gt; provides remote, cloud-based development enviornments. Under the hood, they provision you a Linux VM with Docker. By default, they provide pre-build environments for Rails, C++, PHP, and other enviornments. But not Haxe.&lt;/p&gt;
&lt;p&gt;It turns out that setting up Haxe, OpenFL, and HaxeFlixel is really simple.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;For Haxe, &lt;a href="http://haxe.org/download/"&gt;download&lt;/a&gt; and run the Linux 64-bit binaries. (Copy the &lt;code&gt;tar&lt;/code&gt; URL, eg. &lt;code&gt;http://haxe.org/download/file/3.2.1/haxe-3.2.1-linux64.tar.gz&lt;/code&gt;, and grab it via &lt;code&gt;curl &amp;lt;url&amp;gt;&lt;/code&gt;)&lt;/li&gt;&lt;li&gt;For OpenFL, run &lt;code&gt;haxelib install openfl&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;For HaxeFlixel, run &lt;code&gt;haxelib install flixel&lt;/code&gt;. (Don't forget to install and setup &lt;code&gt;flixel-tools&lt;/code&gt; too.)&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;That's it! You can build your Haxe apps, or your OpenFL/HaxeFlixel games in Flash. To view them:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Find the binary in the workspace view&lt;/li&gt;&lt;li&gt;Right-click and pick Preview&lt;/li&gt;&lt;li&gt;Click the square/arrows icon to open in a new tab&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;This opens the SWF in a new window/tab where it runs properly.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Hue Rotating Sprites in HaxeFlixel</title>
          <link href="http://ashes999.github.io/learnhaxe/hue-rotating-sprites-in-haxeflixel" />
      		<id>urn:uuid:eb29021aa54bd67a78caeea77a433e49</id>
      		<updated>2016-02-21T00:00:00Z</updated>
      		<summary>Hue Rotating Sprites in HaxeFlixel</summary>
      		<content type="xhtml">
      			&lt;p&gt;I began a quest to answer a question: can I hue rotate sprites, within HaxeFlixel itself?  The answer is &lt;em&gt;yes&lt;/em&gt;, although it requires a non-trivial amount of work.&lt;/p&gt;
&lt;p&gt;The first clue is that the HaxeFlixel &lt;code&gt;FlxSprite&lt;/code&gt; class contains a &lt;code&gt;pixels&lt;/code&gt; field, which contains &lt;code&gt;BitmapData&lt;/code&gt;; a list of actual pixel values (colours in the format &lt;code&gt;0xRRGGBB&lt;/code&gt;) which you can access (and manipulate). My first try included changing these via &lt;a href="http://stackoverflow.com/a/8509802/210780"&gt;this formula&lt;/a&gt;; the results looked strange.&lt;/p&gt;
&lt;p&gt;I abandoned that route and decided to use &lt;a href="http://stackoverflow.com/a/8510751/210780"&gt;this method&lt;/a&gt;, which uses a matrix to multiply the RGB component values based on the hue rotation.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BitmapData&lt;/code&gt; has an &lt;a href="http://api.haxeflixel.com/flash/display/BitmapData.html#applyFilter"&gt;applyFilter method&lt;/a&gt;. For the final &lt;code&gt;filter&lt;/code&gt; parameter, which lacks documentation, you can pass in an instance of &lt;code&gt;ColorMatrixFilter&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ColorMatrixFilter&lt;/code&gt; doesn't appear in the HaxeFlixel docs (it's &lt;a href="http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/filters/ColorMatrixFilter.html"&gt;from Flash&lt;/a&gt;). You pass in the values for a 5x4 matrix; the first three columns of the first three rows take in RGB values.&lt;/p&gt;
&lt;p&gt;I translated and passed in the values provided in the Stack Overflow answer above; it looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var hueRotation:Int = 0; // degrees. Tested with values from 0...359
// cosA and sinA are in radians
var cosA:Float = Math.cos(hueRotation * Math.PI / 180);
var sinA:Float = Math.sin(hueRotation * Math.PI / 180);

sprite.pixels.applyFilter(sprite.pixels, sprite.pixels.rect, new Point(), new ColorMatrixFilter(
  [cosA + (1.0 - cosA) / 3.0, 1.0/3.0 * (1.0 - cosA) - Math.sqrt(1.0/3.0) * sinA, 1.0/3.0 * (1.0 - cosA) + Math.sqrt(1.0/3.0) * sinA, 0, 0,
  1.0/3.0 * (1.0 - cosA) + Math.sqrt(1.0/3.0) * sinA, cosA + 1.0/3.0*(1.0 - cosA), 1.0/3.0 * (1.0 - cosA) - Math.sqrt(1.0/3.0) * sinA, 0, 0,
  1.0/3.0 * (1.0 - cosA) - Math.sqrt(1.0/3.0) * sinA, 1.0/3.0 * (1.0 - cosA) + Math.sqrt(1.0/3.0) * sinA, cosA + 1.0/3.0 * (1.0 - cosA), 0, 0,
  0, 0, 0, 1, 0])); // identity row&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output worked:&lt;/p&gt;
&lt;p&gt;&lt;img src="content/images/hue-rotation.png" alt="Hue Rotation Sample Image" /&gt;&lt;/p&gt;
&lt;p&gt;Three three things didn't work as expected:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;I used several copies of the same image, and every copy looked the same. It turns out that HaxeFlixel shares &lt;code&gt;BitmapData&lt;/code&gt; across instances of the same sprite; I bypassed this by setting &lt;code&gt;sprite.pixels = sprite.pixels.clone()&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;The effect didn't apply on Flash. For Flash, you need to add &lt;code&gt;sprite.dirty = true&lt;/code&gt; (possibly in a &lt;code&gt;#if flash&lt;/code&gt; ... &lt;code&gt;#end&lt;/code&gt; block).&lt;/li&gt;&lt;li&gt;The colours are slightly off. If you rotate a simple block of colours (red, green, blue, and white), you see that the colours appear a bit darker than they should be (compare it to what you get in GIMP):&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;img src="content/images/color-skew.png" alt="Off-colors" /&gt;&lt;/p&gt;
&lt;p&gt;The result looks great.  And the performance? In my case, I intended to hue-rotate sprites once (and keep them at that hue forever). Manipulating the sprite's &lt;code&gt;.pixels&lt;/code&gt; directly is the same as loadimg a graphic that already has the transformation -- there's no additional cost in each frame if we only do this once when the sprite is created. (Thanks to &lt;a href="https://github.com/gama11"&gt;Gama11&lt;/a&gt; for pointing this out.)&lt;/p&gt;
&lt;p&gt;For the time being, you can view the complete HaxeFlixel proof-of-concept project &lt;a href="https://github.com/ashes999/haxeflixel-hue-rotation"&gt;here, on GitHub&lt;/a&gt;.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Iterate Over all Fields of Anonymous Structures in Haxe</title>
          <link href="http://ashes999.github.io/learnhaxe/iterate-over-all-fields-of-anonymous-structures-in-haxe" />
      		<id>urn:uuid:94a7e75dcb116844746188990b45172b</id>
      		<updated>2016-02-17T00:00:00Z</updated>
      		<summary>Iterate Over all Fields of Anonymous Structures in Haxe</summary>
      		<content type="xhtml">
      			&lt;p&gt;How do you iterate over all fields of an &lt;a href="http://haxe.org/manual/types-anonymous-structure.html"&gt;anonymous structure&lt;/a&gt; (possibly behind a &lt;code&gt;typedef&lt;/code&gt;) in Haxe and print out all the values?&lt;/p&gt;
&lt;p&gt;The &lt;a href="http://haxe.org/manual/std-reflection.html"&gt;Haxe reflection docs&lt;/a&gt; suggest:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The reflection API consists of two classes:
- Reflect: A lightweight API which work best on anonymous structures, with limited support for classes.
- Type: A more robust API for working with classes and enums.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt; seems promising. From perusing the API docs, I noticed a &lt;code&gt;fields&lt;/code&gt; method. &lt;a href="http://api.haxe.org/Reflect.html#fields"&gt;The docs&lt;/a&gt; say:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;static fields (o:Dynamic):Array&lt;String&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Returns the fields of structure o.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method is only guaranteed to work on anonymous structures. Refer to Type.getInstanceFields for a function supporting class instances.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That looks promising. Running &lt;code&gt;Reflect.fields({ "name": "Butterfly", "version": "0.3" })&lt;/code&gt; gives me the array &lt;code&gt;["name", "version"]&lt;/code&gt; back.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt; also includes &lt;a href="http://api.haxe.org/Reflect.html#getProperty"&gt;a &lt;code&gt;getProperty&lt;/code&gt; method&lt;/a&gt;, which returns the value of a property. Plug this into a for-loop, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var target = { "name": "Butterfly", "version": "0.3" };
var fields = Reflect.fields(target);
for (field in fields) {
  var value = Reflect.getProperty(target, field);
  trace('${field} =&amp;gt; ${value}');
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This traces:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;name =&gt; Butterfly
version =&gt; 0.3&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Also, note that Reflect also &lt;a href="http://api.haxe.org/Reflect.html#field"&gt;contains a &lt;code&gt;field&lt;/code&gt; method&lt;/a&gt; which is syntactically similar to &lt;code&gt;getProperty&lt;/code&gt; (same inputs and outputs); the difference is that &lt;code&gt;field&lt;/code&gt; ignores accessors, while &lt;code&gt;getProperty&lt;/code&gt; applies accessors.&lt;/p&gt;
&lt;p&gt;Given the choice, in this specific case of anonymous structures, I would use &lt;code&gt;field&lt;/code&gt; instead of &lt;code&gt;getProperty&lt;/code&gt; for readability.  This:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (var field in Reflect.fields(target)) { Reflect.field(...) }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Reads more sensibly than:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for (var field in Reflect.fields(target)) { Reflect.getProperty(...) }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If you apply this on something other than an anonymous structure, you should probably opt for &lt;code&gt;getProperty&lt;/code&gt; instead.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Dynamically Adding and Reloading Assets in Haxeflixel</title>
          <link href="http://ashes999.github.io/learnhaxe/dynamically-adding-and-reloading-assets-in-haxeflixel" />
      		<id>urn:uuid:7831ef7024bdda0da3c935848e7e6c2d</id>
      		<updated>2016-01-20T00:00:00Z</updated>
      		<summary>Dynamically Adding and Reloading Assets in Haxeflixel</summary>
      		<content type="xhtml">
      			&lt;p&gt;Yes, you can dynamically load (and reload) assets at runtime in your HaxeFlixel project, courtesy of OpenFL. (Caveat: I tried all this on Neko, although it should work equally on any platform.)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;First, run your project via &lt;code&gt;lime test neko&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Second, add (or modify) your assets to the &lt;code&gt;assets&lt;/code&gt; directory.&lt;/li&gt;&lt;li&gt;Finally, run &lt;code&gt;lime update neko&lt;/code&gt;. This copies and re-bundles the assets, in a way that the running process can access them.&lt;/li&gt;&lt;/ul&gt;
&lt;h2&gt;Internal Details&lt;/h2&gt;
&lt;p&gt;When you run your lime project, it actually creates a copies of the &lt;code&gt;assets&lt;/code&gt; directory in &lt;code&gt;export/&amp;lt;os name&amp;gt;/neko/bin&lt;/code&gt;. Interestingly, copying your asset files here isn't enough; you still need to run &lt;code&gt;lime update neko&lt;/code&gt; to make them accessible to the running game.&lt;/p&gt;
&lt;p&gt;Also, when the assets reload, they become available to calls like &lt;code&gt;getBitmapData&lt;/code&gt; et all. These calls are already (currently) used by HaxeFlixel, so you don't need to do anything more to load them.&lt;/p&gt;
&lt;p&gt;You can see how easy it is to reload assets for a live project, while debugging! I'm sure there are many, many creative possibilities for this (like creating an interactive game editor ...)&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	<entry>
      		<title>Logitech F310 Support in HaxeFlixel</title>
          <link href="http://ashes999.github.io/learnhaxe/logitech-f310-support-in-haxeflixel" />
      		<id>urn:uuid:5b3cc642376ebcf61b696095ee76478e</id>
      		<updated>2016-01-12T00:00:00Z</updated>
      		<summary>Logitech F310 Support in HaxeFlixel</summary>
      		<content type="xhtml">
      			&lt;p&gt;I recently received a &lt;a href="http://gaming.logitech.com/en-us/product/f310-gamepad"&gt;Logitech F310 gamepad&lt;/a&gt;. Since HaxeFlixel already &lt;a href="http://api.haxeflixel.com/flixel/input/gamepad/FlxGamepad.html"&gt;has gamepad support&lt;/a&gt; (buttons, deadzone, D-Pad, etc.), including support for &lt;a href="http://api.haxeflixel.com/flixel/input/gamepad/LogitechButtonID.html"&gt;reading Logitech button input&lt;/a&gt;, I figured it would work out-of-the-box, right?&lt;/p&gt;
&lt;p&gt;Right?&lt;/p&gt;
&lt;p&gt;It turns out that the &lt;code&gt;LogitechButtonID&lt;/code&gt; class contains values based on the &lt;strong&gt;Cordless Rumblepad 2&lt;/strong&gt; controller. If you look &lt;a href="https://www.google.com/search?site=&amp;amp;tbm=isch&amp;amp;source=hp&amp;amp;biw=1440&amp;amp;bih=799&amp;amp;q=rumblepad+2&amp;amp;oq=rumblepad+2&amp;amp;gs_l=img.3..0j0i5i30l9.662.1846.0.1959.11.10.0.1.1.0.151.963.4j5.9.0....0...1ac.1.64.img..1.10.964.x4VlaV7zemA"&gt;at screenshots&lt;/a&gt;, you'll notice the pads all have numbers on them.&lt;/p&gt;
&lt;p&gt;That's no good -- the F310 uses &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; for buttons, with left and right triggers (&lt;code&gt;LB&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt; respectively). Fortunately, the LogitechButtonID class' comments indicate which value applise to which button; these values match up exactly with the F310.  For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline read only FOUR:Int = 11
Placement equivalent to 'Y' button on the Xbox 360 controller&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That only leaves the D-Pads. The built in enum values don't work; instead, I used &lt;a href="https://github.com/HaxeFlixel/flixel/blob/master/flixel/input/gamepad/FlxGamepad.hx#L39"&gt;the four &lt;code&gt;dpad*&lt;/code&gt; properties&lt;/a&gt; defined on the controller itself; these work perfectly.&lt;/p&gt;
&lt;p&gt;If you want to try this for yourself, it's quite easy:&lt;/p&gt;
&lt;p&gt;1) Run &lt;code&gt;flixel create&lt;/code&gt; and then select demo &lt;code&gt;34&lt;/code&gt;, &lt;code&gt;GamepadTest&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;2) Replace the contents of the &lt;code&gt;GamepadIDs&lt;/code&gt; class with the correct button enum values:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static inline var A = LogitechButtonID.TWO;
public static inline var B = LogitechButtonID.THREE;
public static inline var X = LogitechButtonID.ONE;
public static inline var Y = LogitechButtonID.FOUR;
public static inline var LB = LogitechButtonID.FIVE;
public static inline var RB = LogitechButtonID.SIX;
public static inline var START = LogitechButtonID.TEN;
public static inline var SELECT = LogitechButtonID.NINE;
public static inline var LEFT_ANALOGUE = LogitechButtonID.LEFT_ANALOGUE;
public static inline var RIGHT_ANALOGUE = LogitechButtonID.RIGHT_ANALOGUE;
public static inline var LEFT_ANALOGUE_X = LogitechButtonID.LEFT_ANALOGUE_X;
public static inline var LEFT_ANALOGUE_Y = LogitechButtonID.LEFT_ANALOGUE_Y;
public static inline var RIGHT_ANALOGUE_X = LogitechButtonID.RIGHT_ANALOGUE_X;
public static inline var RIGHT_ANALOGUE_Y =  LogitechButtonID.RIGHT_ANALOGUE_Y;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3) Modify &lt;code&gt;PlayState.hx&lt;/code&gt;'s &lt;code&gt;updateDpad&lt;/code&gt; function; the values assigned to the four &lt;code&gt;dpad*&lt;/code&gt; variables should be:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dpadLeft = _gamePad.dpadLeft;
var dpadRight = _gamePad.dpadRight;
var dpadUp = _gamePad.dpadUp;
var dpadDown = _gamePad.dpadDown;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run &lt;code&gt;lime test neko&lt;/code&gt; and observe that all input displays as expected.&lt;/p&gt;
      		</content>
      		<author>
      			<name>ashes999</name>
      			<email>ashes999@yahoo.com</email>
      		</author>
      	</entry>
      	</feed>